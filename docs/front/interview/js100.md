---
title: JS题51-100
date: 2022-03-15
---
## 51.id选择器问题
:::: tabs
::: tab label=题
* 《你不知道的JS(中)》p126
* id选择器会在全局创建一个同名变量
```html
<body>
    <div id="foo"></div>
    <script>
        console.log(foo); // div#foo (DOM元素)

    </script>
</body>
```
:::
::: tab label=问题变形
* var声明后有会把它覆盖掉
```html
<body>
    <div id="foo">啦啦啦</div>
    <script>
        console.log(foo); // undefined
        if (typeof foo === 'undefined') {
            var foo = 100;
        }
        console.log(foo); // 100

    </script>
</body>
```
:::
::::
## 52.Worker作用
:::: tabs
::: tab label=题
* 《你不知道的JS（中）》p288
* JS是单线程语言，所有的执行都是`单线程操作`
* 因此JS的异步不是像JAVA那样多开一个thread线程来进行操作，而是使用`事件轮询机制`
* 遇到问题：一个`同步操作`涉及大量计算时程序会卡死：
>点击程序卡死按钮后计算器不能正常运行操作，因为单线程正忙着呢
```html{10,19-21}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Worker的作用</title>
</head>

<body>
    <button id="temp">点我程序卡死十秒</button>
    <div>计算器</div>
    <button id="del">-</button>
    <div id="num">0</div>
    <button id="add">+</button>

    <script>
        temp.addEventListener('click', () => {
            const end = Date.now() + 10000;
            console.log('大量计算中');
            while (Date.now() < end) {}
            console.log('计算完毕');
        });
        del.addEventListener('click', () => {
            num.innerText = +num.innerText - 1;
        })
        add.addEventListener('click', () => {
            num.innerText = +num.innerText + 1;
        })

    </script>
</body>

</html>
```
:::
::: tab label=server.js
* [worker](../base/worker.html)给JS执行提供多线程操作空间
>worker应该是一个`网络文件`，属于一个半封闭环境，里面可以定义一些方法，和指定的事件监听钩子
```js
const express = require('express');
const fs = require('fs');
const path = require('path');
const app = express();
app.listen('8888', () => console.log('listen 8888'));

app.get('/', (req, res) => {
    res.setHeader('Content-Type', 'text/html')
    const url = path.join(__dirname, './test.html');
    const code = fs.readFileSync(url);
    return res.send(code);
})

app.get('/worker', (req, res) => {
    res.setHeader('Content-Type', 'text/javascript')
    const url = path.join(__dirname, './worker.js');
    const code = fs.readFileSync(url);
    res.send(code)
})
```
:::
::: tab label=worker.js
* 将大量计算的代码放到这个空间里面，空间里面不能涉及DOM操作、全局window对象获取、跨域等都有限制
```js
onmessage = e => {
    console.log(e.data);
    const end = Date.now() + 10000;
    console.log('大量计算中');
    while (Date.now() < end) { }
    console.log('计算完毕');
    postMessage({ num: end });
}
```
:::
::: tab label=test.html
* 有大量耗时操作的地方传到worker线程去计算，计算玩返回给JS主线程结果，让主线程不被卡死
```html{17-21}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Worker的作用</title>
</head>

<body>
    <button id="temp">点我程序卡死十秒</button>
    <div>计算器</div>
    <button id="del">-</button>
    <div id="num">0</div>
    <button id="add">+</button>

    <script>
        const worker = new Worker('./worker');
        worker.onmessage = e => console.log(e);
        temp.addEventListener('click', () => {
            worker.postMessage('add');
        });
        del.addEventListener('click', () => {
            num.innerText = +num.innerText - 1;
        })
        add.addEventListener('click', () => {
            num.innerText = +num.innerText + 1;
        })
    </script>
</body>

</html>
```
:::
::::
## 53.正则2
:::: tabs
::: tab label=题
* 正则检查数字，最多12个数字，小数点后最多三个
```js
const a = '123.33'; // true
const b = '1223.3333'; // false
const c = '324123.033'; // true
const d = '324123'; // true
const e = '123456789012'; // true
const f = '1234567890122'; // false
const g = '12345678.9012'; // false
const h = '12345678.012'; // true

console.log(valNum(a));
console.log(valNum(b));
console.log(valNum(c));
console.log(valNum(d));
console.log(valNum(e));
console.log(valNum(f));
console.log(valNum(g));
console.log(valNum(h));
```
:::
::: tab label=解
* 或【|】表达式需要用括号括起来，而不需要捕获这段括号，用`环视`
```js
function valNum(num) {
    const reg1 = /^(\d{0,9})(?:\d{0,3}|\d{0,2}\.\d|\d?\.\d{2}|\.\d{3})$/;
    return reg1.test(num);
}
```
:::
::::
## 54.super对象
:::: tabs
::: tab label=题
《你不知道的JS（下）》p97
```js{12}
const a = {
    name: 'hdy',
    say() {
        console.log(this.name);
    }

};

const b = {
    age: 18,
    say: function () {
        super.say();
        console.log(this.age);
    }
}
Object.setPrototypeOf(b, a);

b.say(); // 输出？
```
:::
::: tab label=解
* super关键字只能在`简洁方法`中使用，所以function直接调用会报错
```js
const a = {
    name: 'hdy',
    say() {
        console.log(this.name);
    }

};

const b = {
    age: 18,
    // say: function () {
    say() {
        super.say();
        console.log(this.age);
    }
}
Object.setPrototypeOf(b, a);

b.say();
```
>简洁方法：将对象中的function省略掉，直接写函数形式
:::
::::
## 55.Symbol问题
:::: tabs
::: tab label=题
* 《你不知道的JS（下）》p125
* 输出与原因
```js
const age = Symbol('age');
const obj = {
    name: 'hdy',
    age: 18,
    [age]: 19
}
console.log(obj.age);
console.log(obj[age]);
```
:::
::: tab label=解
* Symbol是独一无二的存在，有避免混淆的作用，所以如果要创建一个避免被覆盖的变量，可以用Symbol
* 同时要注意作用域，如果要访问该变量，就要让Symbol也能被访问到的作用域
:::
::::
## 56.首屏渲染时间
:::: tabs
::: tab label=时间点
1. 最精确的开始时间：`performance.timeOrigin`
2. (慢几十毫秒)首屏index头部加上script`Date.now()`
3. css加载、html加载、图片加载、script加载
4. 每个url请求元素都可以绑定`onload`事件拿到加载完毕事件，如img
5. 整体加载完毕`window.onload`，加载文件完成后就可以渲染，这里可拿到`白屏时间`
6. 页面渲染
7. 加载完后js执行，可能会渲染元素上屏，如：vue组件内有图片，图片地址需要ajax异步得到，图片加载完毕后拿到的是`首屏时间`
>完全静态的文件可以通过`window.onload`事件中`Date.now() - performance.timeOrigin`计算整个文件的加载时间，渲染时间根据浏览器性能差异会慢一点  
>现在的框架基本都是动态前端页面，所以需要`动态计算`，并且**首屏时间应该是用户能看到的首屏渲染时间**，与看不到的内容无关
:::
::: tab label=判断首屏
* 页面加载完成，css和html组成`render tree`的时候，各元素的值已经可以正确获取，可以通过`ele.getBoundingClientRect()`或`ele.offsetTop叠加计算`获取
```js
function inFirstScreen(ele) {
    const rect = ele.getBoundingClientRect();
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    const rectLeft = rect.left;
    const rectTop = rect.top;
    return rectLeft <= screenWidth && rectTop <= screenHeight;
}
```
>注：获取dom的offset等`渲染坐标、大小等`数据会触发页面重排，先取出来再使用，提升性能
:::
:::  tab label=图片判断
* 一般影响主要渲染时间的是图片等多媒体element，所以一般计算首页图片加载完毕的时间基本就可以判定为首屏时间
```js
const imgs = Array.from(document.getElementsByTagName('img'));
imgs.forEach(item => {
    if (inFirstScreen(item)) {
        item.addEventListener('load', () => {
            if (inFirstScreen(item)) {
                console.log(Date.now() - performance.timeOrigin);
            }
        });
    }
})
```
* 判断了两次`inFirstScreen`：
    * 第一次是首屏元素判断，说明这个元素**可能出现在首屏中**，防止添加过多无效的事件
    * 加载完毕后再判断一次，说明此元素**一定是在首屏**中，因为可能会被别的没提前设置高度的元素(如图片)给挤到屏幕外面去。
:::
::: tab label=静态计算
* 静态计算适合于首页：**img标签本来就有，但是具体url是动态获取的**。
```html{45-67}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, viewport-fit=cover, user-scalable=no">
    <meta charset="UTF-8">
    <style>
        #temp {
            height: 100px;
            width: 100px;
            background-color: rgb(192, 41, 41);
        }

        #img2 {
            height: 100px;
        }

    </style>
    <title>首屏时间计算</title>

</head>

<body>
    <button id="temp">啦啦啦啦</button>
    <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <img src="" alt="" id="img">
    <img src="" alt="" id="img2">
    <script>
        setTimeout(() => img.setAttribute('src', 'https://coderhdy.com/assets/img/bgimg.jpg'), 1000);
        setTimeout(() => img2.setAttribute('src', 'https://coderhdy.com/assets/img/bgimg.jpg'), 1000);

        const firstScreenTime = new Promise(resolve => {
            const inFirstScreen = (ele) => {
                const rect = ele.getBoundingClientRect();
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const rectLeft = rect.left;
                const rectTop = rect.top;
                return rectLeft <= screenWidth && rectTop <= screenHeight;
            }
            const imgs = Array.from(document.getElementsByTagName('img'));
            let ans = 0;
            imgs.forEach(item => {
                if (inFirstScreen(item)) {
                    item.addEventListener('load', () => {
                        if (inFirstScreen(item)) {
                            ans = Date.now() - performance.timeOrigin;
                        }
                    });
                }
            });
            setTimeout(() => resolve(ans), 5000)
        });
        firstScreenTime.then(res => console.log(res));

    </script>
</body>

</html>
```
:::
::: tab label=动态计算
* 在首页中，如果有**列表或判断类动态渲染出img数量的标签**，就需要动态计算，因为不确定是什么时候添加进来的，就不能在最开始执行的时候添加事件监听。
```html{37-47,70-75,79-80}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, viewport-fit=cover, user-scalable=no">
    <meta charset="UTF-8">
    <style>
        #temp {
            height: 100px;
            width: 100px;
            background-color: rgb(192, 41, 41);
        }

        img {
            display: inline-block;
            width: 120px;
            height: 200px;
            padding: 20px;
        }

    </style>
    <title>首屏时间计算</title>

</head>

<body>
    <button id="temp">啦啦啦啦</button>
    <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <div id="imgs">
    </div>
    <script>
        // 定时添加不定量图片，可能会溢出屏幕
        new Promise(resolve => {
            setTimeout(resolve, 1000)
        }).then(() => {
            const imgNum = Math.ceil(Math.random() * 10) + 1;
            for (let i = 0; i < imgNum; i++) {
                const img = document.createElement('img');
                img.setAttribute('src', 'https://coderhdy.com/assets/img/bgimg.jpg');
                imgs.appendChild(img);
            }
        })
        const firstScreenTime = new Promise(resolve => {
            const inFirstScreen = (ele) => {
                const rect = ele.getBoundingClientRect();
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const rectLeft = rect.left;
                const rectTop = rect.top;
                return rectLeft <= screenWidth && rectTop <= screenHeight;
            }
            const timeAdder = item => {
                if (inFirstScreen(item)) {
                    item.addEventListener('load', () => {
                        if (inFirstScreen(item)) {
                            ans = Date.now() - performance.timeOrigin;
                        }
                    });
                }
            }
            const imgs = Array.from(document.getElementsByTagName('img'));
            let ans = 0;
            imgs.forEach(timeAdder);

            // 修改原生的appendChild
            const native = Element.prototype.appendChild;
            Element.prototype.appendChild = function (ele) {
                native.call(this, ele);
                timeAdder(ele);
            }
            setTimeout(() => {
                resolve(ans);

                // 使用完毕改回去
                Element.prototype.appendChild = native;
            }, 5000)
        });
        firstScreenTime.then(res => console.log(res));

    </script>
</body>

</html>
```
:::
::::
## 57.addEventListener移除
:::: tabs
::: tab label=removeEventListener
```html
<body>
    <button id="temp">啦啦啦啦</button>

    <script>
        function c() {
            console.log('---')
        }

        temp.addEventListener('click', c);
        setTimeout(() => temp.removeEventListener('click', c), 3000)
    </script>
</body>
```
:::
::: tab label=signal
* 第三个`options`参数设置signal，通过AbortController控制
```html{9-10,12}
<body>
    <button id="temp">啦啦啦啦</button>

    <script>
        function c() {
            console.log('---')
        }

        const controler = new AbortController();
        setTimeout(() => controler.abort(), 3000)
        temp.addEventListener('click', c, {
            signal: controler.signal
        });
    </script>
</body>
```
:::
::: tab label=once
* 第三个`options`参数设置once，触发一次后自动移除
```html{10}
<body>
    <button id="temp">啦啦啦啦</button>

    <script>
        function c() {
            console.log('---')
        }

        temp.addEventListener('click', c, {
            once: true
        });
    </script>
</body>
```
:::
::::
## 58.红绿灯
:::: tabs
::: tab label=题
* 实现红绿灯交替打印的**异步函数**
```js
trafic(3000, 1000, 2000);
// red 停3秒 yellow 停1秒 green 停2秒 循环

console.log('同步代码不阻塞');
```
:::
::: tab label=解
* await返回的是`Promise.resolve`包装的一个`promise`，所以用promise控制时间流转
```js
async function trafic(red, yellow, green) {
    const sleep = time => new Promise(resolve => setTimeout(resolve, time));
    while (true) {
        console.log('red');
        await sleep(red);
        console.log('yellow');
        await sleep(yellow);
        console.log('green');
        await sleep(green);
    }
}
```
:::
::: tab label=结束控制
* while增加一个变量控制结束，将变量的控制器返回出去。
```js
function trafic(red, yellow, green) {
    const sleep = time => new Promise(resolve => setTimeout(resolve, time));
    let stop = false;
    const controller = () => stop = true;
    const timer = async () => {
        while (!stop) {
            console.log('red');
            await sleep(red);

            if (stop) break;
            console.log('yellow');
            await sleep(yellow);

            if (stop) break;
            console.log('green');
            await sleep(green);
        }
    }
    timer();
    return controller;
}


const a = trafic(3000, 1000, 2000);

setTimeout(a, 10000);
```
>`trafic`函数是正常函数，`timer`函数是异步函数，被async包装成了promise，然而内部的循环控制器`controller`被`trafic`函数返回了出去。
:::
::::
## 59.+优先级
:::: tabs
::: tab label=题
```js
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing'); // ??
```
:::
::: tab label=解
```js
// + 优先级优于 三元运算符
// Something
```
:::
::::