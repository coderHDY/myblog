---
title: js题51-100
date: 2022-03-15
---
## 51.id选择器问题
:::: tabs
::: tab label=题
* 《你不知道的JS(中)》p126
* id选择器会在全局创建一个同名变量
```html
<body>
    <div id="foo"></div>
    <script>
        console.log(foo); // div#foo (DOM元素)

    </script>
</body>
```
:::
::: tab label=问题变形
* var声明后有会把它覆盖掉
```html
<body>
    <div id="foo">啦啦啦</div>
    <script>
        console.log(foo); // undefined
        if (typeof foo === 'undefined') {
            var foo = 100;
        }
        console.log(foo); // 100

    </script>
</body>
```
:::
::::
## 52.Worker作用
:::: tabs
::: tab label=题
* 《你不知道的JS（中）》p288
* JS是单线程语言，所有的执行都是`单线程操作`
* 因此JS的异步不是像JAVA那样多开一个thread线程来进行操作，而是使用`事件轮询机制`
* 遇到问题：一个`同步操作`涉及大量计算时程序会卡死：
>点击程序卡死按钮后计算器不能正常运行操作，因为单线程正忙着呢
```html{10,19-21}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Worker的作用</title>
</head>

<body>
    <button id="temp">点我程序卡死十秒</button>
    <div>计算器</div>
    <button id="del">-</button>
    <div id="num">0</div>
    <button id="add">+</button>

    <script>
        temp.addEventListener('click', () => {
            const end = Date.now() + 10000;
            console.log('大量计算中');
            while (Date.now() < end) {}
            console.log('计算完毕');
        });
        del.addEventListener('click', () => {
            num.innerText = +num.innerText - 1;
        })
        add.addEventListener('click', () => {
            num.innerText = +num.innerText + 1;
        })

    </script>
</body>

</html>
```
:::
::: tab label=server.js
* [worker](../base/worker.html)给JS执行提供多线程操作空间
>worker应该是一个`网络文件`，属于一个半封闭环境，里面可以定义一些方法，和指定的事件监听钩子
```js
const express = require('express');
const fs = require('fs');
const path = require('path');
const app = express();
app.listen('8888', () => console.log('listen 8888'));

app.get('/', (req, res) => {
    res.setHeader('Content-Type', 'text/html')
    const url = path.join(__dirname, './test.html');
    const code = fs.readFileSync(url);
    return res.send(code);
})

app.get('/worker', (req, res) => {
    res.setHeader('Content-Type', 'text/javascript')
    const url = path.join(__dirname, './worker.js');
    const code = fs.readFileSync(url);
    res.send(code)
})
```
:::
::: tab label=worker.js
* 将大量计算的代码放到这个空间里面，空间里面不能涉及DOM操作、全局window对象获取、跨域等都有限制
```js
onmessage = e => {
    console.log(e.data);
    const end = Date.now() + 10000;
    console.log('大量计算中');
    while (Date.now() < end) { }
    console.log('计算完毕');
    postMessage({ num: end });
}
```
:::
::: tab label=test.html
* 有大量耗时操作的地方传到worker线程去计算，计算玩返回给JS主线程结果，让主线程不被卡死
```html{17-21}
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Worker的作用</title>
</head>

<body>
    <button id="temp">点我程序卡死十秒</button>
    <div>计算器</div>
    <button id="del">-</button>
    <div id="num">0</div>
    <button id="add">+</button>

    <script>
        const worker = new Worker('./worker');
        worker.onmessage = e => console.log(e);
        temp.addEventListener('click', () => {
            worker.postMessage('add');
        });
        del.addEventListener('click', () => {
            num.innerText = +num.innerText - 1;
        })
        add.addEventListener('click', () => {
            num.innerText = +num.innerText + 1;
        })
    </script>
</body>

</html>
```
:::
::::
## 53.正则2
:::: tabs
::: tab label=题
* 正则检查数字，最多12个数字，小数点后最多三个
```js
const a = '123.33'; // true
const b = '1223.3333'; // false
const c = '324123.033'; // true
const d = '324123'; // true
const e = '123456789012'; // true
const f = '1234567890122'; // false
const g = '12345678.9012'; // false
const h = '12345678.012'; // true

console.log(valNum(a));
console.log(valNum(b));
console.log(valNum(c));
console.log(valNum(d));
console.log(valNum(e));
console.log(valNum(f));
console.log(valNum(g));
console.log(valNum(h));
```
:::
::: tab label=解
* 或【|】表达式需要用括号括起来，而不需要捕获这段括号，用`环视`
```js
function valNum(num) {
    const reg1 = /^(\d{0,9})(?:\d{0,3}|\d{0,2}\.\d|\d?\.\d{2}|\.\d{3})$/;
    return reg1.test(num);
}
```
:::
::::
## 54.super对象
:::: tabs
::: tab label=题
《你不知道的JS（下）》p97
```js{12}
const a = {
    name: 'hdy',
    say() {
        console.log(this.name);
    }

};

const b = {
    age: 18,
    say: function () {
        super.say();
        console.log(this.age);
    }
}
Object.setPrototypeOf(b, a);

b.say(); // 输出？
```
:::
::: tab label=解
* super关键字只能在`简洁方法`中使用，所以function直接调用会报错
```js
const a = {
    name: 'hdy',
    say() {
        console.log(this.name);
    }

};

const b = {
    age: 18,
    // say: function () {
    say() {
        super.say();
        console.log(this.age);
    }
}
Object.setPrototypeOf(b, a);

b.say();
```
>简洁方法：将对象中的function省略掉，直接写函数形式
:::
::::
## 55.Symbol问题
:::: tabs
::: tab label=题
* 《你不知道的JS（下）》p125
* 输出与原因
```js
const age = Symbol('age');
const obj = {
    name: 'hdy',
    age: 18,
    [age]: 19
}
console.log(obj.age);
console.log(obj[age]);
```
:::
::: tab label=解
* Symbol是独一无二的存在，有避免混淆的作用，所以如果要创建一个避免被覆盖的变量，可以用Symbol
* 同时要注意作用域，如果要访问该变量，就要让Symbol也能被访问到的作用域
:::
::::
## 56.首屏渲染时间
:::: tabs
::: tab label=时间点
1. 最精确的开始时间：`performance.timeOrigin`
2. (慢几十毫秒)首屏index头部加上script`Date.now()`
3. css加载、html加载、图片加载、script加载
4. 每个url请求元素都可以绑定`onload`事件拿到加载完毕事件，如img
5. 整体加载完毕`window.onload`，加载文件完成后就可以渲染，这里可拿到`白屏时间`
6. 页面渲染
7. 加载完后js执行，可能会渲染元素上屏，如：vue组件内有图片，图片地址需要ajax异步得到，图片加载完毕后拿到的是`首屏时间`
>完全静态的文件可以通过`window.onload`事件中`Date.now() - performance.timeOrigin`计算整个文件的加载时间，渲染时间根据浏览器性能差异会慢一点  
>现在的框架基本都是动态前端页面，所以需要`动态计算`，并且**首屏时间应该是用户能看到的首屏渲染时间**，与看不到的内容无关
:::
::: tab label=判断首屏
* 页面加载完成，css和html组成`render tree`的时候，各元素的值已经可以正确获取，可以通过`ele.getBoundingClientRect()`或`ele.offsetTop叠加计算`获取
```js
function inFirstScreen(ele) {
    const rect = ele.getBoundingClientRect();
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    const rectLeft = rect.left;
    const rectTop = rect.top;
    return rectLeft <= screenWidth && rectTop <= screenHeight;
}
```
>注：获取dom的offset等`渲染坐标、大小等`数据会触发页面重排，先取出来再使用，提升性能
:::
:::  tab label=图片判断
* 一般影响主要渲染时间的是图片等多媒体element，所以一般计算首页图片加载完毕的时间基本就可以判定为首屏时间
```js
const imgs = Array.from(document.getElementsByTagName('img'));
imgs.forEach(item => {
    if (inFirstScreen(item)) {
        item.addEventListener('load', () => {
            if (inFirstScreen(item)) {
                console.log(Date.now() - performance.timeOrigin);
            }
        });
    }
})
```
* 判断了两次`inFirstScreen`：
    * 第一次是首屏元素判断，说明这个元素**可能出现在首屏中**，防止添加过多无效的事件
    * 加载完毕后再判断一次，说明此元素**一定是在首屏**中，因为可能会被别的没提前设置高度的元素(如图片)给挤到屏幕外面去。
:::
::: tab label=静态计算
* 静态计算适合于首页：**img标签本来就有，但是具体url是动态获取的**。
```html{45-67}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, viewport-fit=cover, user-scalable=no">
    <meta charset="UTF-8">
    <style>
        #temp {
            height: 100px;
            width: 100px;
            background-color: rgb(192, 41, 41);
        }

        #img2 {
            height: 100px;
        }

    </style>
    <title>首屏时间计算</title>

</head>

<body>
    <button id="temp">啦啦啦啦</button>
    <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <img src="" alt="" id="img">
    <img src="" alt="" id="img2">
    <script>
        setTimeout(() => img.setAttribute('src', 'https://coderhdy.com/assets/img/bgimg.jpg'), 1000);
        setTimeout(() => img2.setAttribute('src', 'https://coderhdy.com/assets/img/bgimg.jpg'), 1000);

        const firstScreenTime = new Promise(resolve => {
            const inFirstScreen = (ele) => {
                const rect = ele.getBoundingClientRect();
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const rectLeft = rect.left;
                const rectTop = rect.top;
                return rectLeft <= screenWidth && rectTop <= screenHeight;
            }
            const imgs = Array.from(document.getElementsByTagName('img'));
            let ans = 0;
            imgs.forEach(item => {
                if (inFirstScreen(item)) {
                    item.addEventListener('load', () => {
                        if (inFirstScreen(item)) {
                            ans = Date.now() - performance.timeOrigin;
                        }
                    });
                }
            });
            setTimeout(() => resolve(ans), 5000)
        });
        firstScreenTime.then(res => console.log(res));

    </script>
</body>

</html>
```
:::
::: tab label=动态计算
* 在首页中，如果有**列表或判断类动态渲染出img数量的标签**，就需要动态计算，因为不确定是什么时候添加进来的，就不能在最开始执行的时候添加事件监听。
```html{37-47,70-75,79-80}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, viewport-fit=cover, user-scalable=no">
    <meta charset="UTF-8">
    <style>
        #temp {
            height: 100px;
            width: 100px;
            background-color: rgb(192, 41, 41);
        }

        img {
            display: inline-block;
            width: 120px;
            height: 200px;
            padding: 20px;
        }

    </style>
    <title>首屏时间计算</title>

</head>

<body>
    <button id="temp">啦啦啦啦</button>
    <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <div id="imgs">
    </div>
    <script>
        // 定时添加不定量图片，可能会溢出屏幕
        new Promise(resolve => {
            setTimeout(resolve, 1000)
        }).then(() => {
            const imgNum = Math.ceil(Math.random() * 10) + 1;
            for (let i = 0; i < imgNum; i++) {
                const img = document.createElement('img');
                img.setAttribute('src', 'https://coderhdy.com/assets/img/bgimg.jpg');
                imgs.appendChild(img);
            }
        })
        const firstScreenTime = new Promise(resolve => {
            const inFirstScreen = (ele) => {
                const rect = ele.getBoundingClientRect();
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const rectLeft = rect.left;
                const rectTop = rect.top;
                return rectLeft <= screenWidth && rectTop <= screenHeight;
            }
            const timeAdder = item => {
                if (inFirstScreen(item)) {
                    item.addEventListener('load', () => {
                        if (inFirstScreen(item)) {
                            ans = Date.now() - performance.timeOrigin;
                        }
                    });
                }
            }
            const imgs = Array.from(document.getElementsByTagName('img'));
            let ans = 0;
            imgs.forEach(timeAdder);

            // 修改原生的appendChild
            const native = Element.prototype.appendChild;
            Element.prototype.appendChild = function (ele) {
                native.call(this, ele);
                timeAdder(ele);
            }
            setTimeout(() => {
                resolve(ans);

                // 使用完毕改回去
                Element.prototype.appendChild = native;
            }, 5000)
        });
        firstScreenTime.then(res => console.log(res));

    </script>
</body>

</html>
```
:::
::::
## 57.addEventListener移除
:::: tabs
::: tab label=removeEventListener
```html
<body>
    <button id="temp">啦啦啦啦</button>

    <script>
        function c() {
            console.log('---')
        }

        temp.addEventListener('click', c);
        setTimeout(() => temp.removeEventListener('click', c), 3000)
    </script>
</body>
```
:::
::: tab label=signal
* 第三个`options`参数设置signal，通过AbortController控制
```html{9-10,12}
<body>
    <button id="temp">啦啦啦啦</button>

    <script>
        function c() {
            console.log('---')
        }

        const controler = new AbortController();
        setTimeout(() => controler.abort(), 3000)
        temp.addEventListener('click', c, {
            signal: controler.signal
        });
    </script>
</body>
```
:::
::: tab label=once
* 第三个`options`参数设置once，触发一次后自动移除
```html{10}
<body>
    <button id="temp">啦啦啦啦</button>

    <script>
        function c() {
            console.log('---')
        }

        temp.addEventListener('click', c, {
            once: true
        });
    </script>
</body>
```
:::
::::
## 58.红绿灯
:::: tabs
::: tab label=题
* 实现红绿灯交替打印的**异步函数**
```js
trafic(3000, 1000, 2000);
// red 停3秒 yellow 停1秒 green 停2秒 循环

console.log('同步代码不阻塞');
```
:::
::: tab label=解
* await返回的是`Promise.resolve`包装的一个`promise`，所以用promise控制时间流转
```js
async function trafic(red, yellow, green) {
    const sleep = time => new Promise(resolve => setTimeout(resolve, time));
    while (true) {
        console.log('red');
        await sleep(red);
        console.log('yellow');
        await sleep(yellow);
        console.log('green');
        await sleep(green);
    }
}
```
:::
::: tab label=结束控制
* while增加一个变量控制结束，将变量的控制器返回出去。
```js
function trafic(red, yellow, green) {
    const sleep = time => new Promise(resolve => setTimeout(resolve, time));
    let stop = false;
    const controller = () => stop = true;
    const timer = async () => {
        while (!stop) {
            console.log('red');
            await sleep(red);

            if (stop) break;
            console.log('yellow');
            await sleep(yellow);

            if (stop) break;
            console.log('green');
            await sleep(green);
        }
    }
    timer();
    return controller;
}


const stop = trafic(3000, 1000, 2000);

setTimeout(stop, 10000);
```
>`trafic`函数是正常函数，`timer`函数是异步函数，被async包装成了promise，然而内部的循环控制器`controller`被`trafic`函数返回了出去。
:::
::::
## 59.+优先级
:::: tabs
::: tab label=题
```js
var val = 'smtg';
console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing'); // ??
```
:::
::: tab label=解
```js
// + 优先级优于 三元运算符
// Something
```
:::
::::
## 60.节流事件
:::: tabs
::: tab label=题
* 写一个组件，上面显示当前窗口的 width/height
* 要求：
    1. resize同时要监听
    2. 监听器的移除
    3. 节流
:::
::: tab label=解
* app模拟添加、移除size组件
* size组件显示当前视口宽高
* mounted添加事件监听，beforeDestroy移除监听
* methods里面方法this是绑定好的
```html
<body>
    <div id="app">
        <button @click="toggle">toggle</button>

        <size v-if="show"></size>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script>
        const size = {
            template: `
            <div>
                width: {{width}}
                <hr />
                height: {{height}}
            </div>
            `,
            data() {
                return {
                    width: 0,
                    height: 0,
                    listener: null,
                }
            },
            mounted() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.listener = this.resize()
                window.addEventListener('resize', this.listener);
            },
            methods: {
                resize() {
                    let timer;
                    return () => {
                        if (timer) return;
                        timer = setTimeout(() => {
                            console.log('resize');
                            this.width = window.innerWidth;
                            this.height = window.innerHeight;
                            timer = null;
                        }, 100);
                    }
                }
            },
            beforeDestroy() {
                console.log('destroy');
                window.removeEventListener('resize', this.listener);
            }
        };
        const app = new Vue({
            el: '#app',
            components: {
                size
            },
            data() {
                return {
                    show: true,
                }
            },
            methods: {
                toggle() {
                    this.show = !this.show;
                }
            }
        });

    </script>
</body>
```
:::
::::
## 61.instanceof
:::: tabs
::: tab label=题
```js
console.log('sdf' instanceof String);
```
:::
::: tab label=解
* 字面量`string`/`number`/`boolean`本质上不是对象，是基础类型，没有原型链，只不过js在处理字面量调用方法的时候会将其包装成对象来进行方法的调用
```js
console.log('sdf' instanceof String); // false
console.log(new String('sdf') instanceof String); // true
```
:::
::::
## 62.this2
:::: tabs
::: tab label=题
* 这两段代码在浏览器的异同
```js
function A() {
    this.say = function () { console.log(this.name) };
}

window.name = 'iii';
const a = new A();
const say = a.say;
say()
```
```js
class A {
    say() { console.log(this.name) };
}

window.name = 'iii';
const a = new A();
const say = a.say;

say()
```
:::
::: tab label=题
* 在浏览器中，class属于是es6，es6里函数默认调用的时候this不会指向window
:::
::::
## 63.数组转对象
:::: tabs
::: tab label=题
```js
const arr = ['a', 'b', 'c', 'd', 'e', 'f'];
console.log(modify(arr));
// {'a': {'b': {'c': {'d': {'e': 'f'}}}}}
```
:::
::: tab label=解
```js
function modify(arr) {
    return arr.reduceRight((pre, item) => pre === null ? item : { [item]: pre }, null);
}
```
:::
::::
## 64.收集所有的DOM元素
:::: tabs
::: tab label=题
* 输出页面所有的DOM元素的tag（去重）
:::
::: tab label=解
```html
<body>
    <div class="container">
        <p>
            <span></span>
        </p>
    </div>
    <hr>
    <form action="">
        <input type="text">
    </form>
    <script>
        function getAllTags() {
            const ans = new Set();
            const handler = (ele) => {
                ans.add(ele.tagName);
                const children = ele.children;
                Array.prototype.forEach.call(children, item => handler(item));
            }
            handler(document.querySelector('body'));
            return [...ans];
        }

        console.log(getAllTags());

    </script>
</body>
```
:::
::::
## 65.多维数组全排列
:::: tabs
::: tab label=题
```js
const arr = [['A', 'B'], ['a', 'b'], [1, 2]]
console.log(sort(arr));
// [
//     'Aa1', 'Aa2',
//     'Ab1', 'Ab2',
//     'Ba1', 'Ba2',
//     'Bb1', 'Bb2'
// ]
```
:::
::: tab label=解
```js
function sort(arr) {
    const ans = [];
    const handler = (i, str) => {
        if (i === arr.length) return ans.push(str);
        for (let j = 0; j < arr[0].length; j++) {
            handler(i + 1, `${str}${arr[i][j]}`)
        }
    };
    handler(0, '');
    return ans;
}
```
:::
::::
## 66.交并集
:::: tabs
::: tab label=交集
```js
function test(arr1, arr2) {
    return [...(new Set([...arr1, ...arr2]))];
}

const arr1 = [1, 2, 3, 4, 5, 6];
const arr2 = [19, 23, 3, 41, 5, 6];
console.log(test2(arr1, arr2))
```
:::
::: tab label=并集
```js
function test2(arr1, arr2) {
    return arr1.filter(item => arr2.includes(item));
}

const arr1 = [1, 2, 3, 4, 5, 6];
const arr2 = [19, 23, 3, 41, 5, 6];
console.log(test2(arr1, arr2))
```
:::
::::
## 67.手写继承
:::: tabs
::: tab label=解
```js
function Parent(data) {
    this.data = data;
}
Parent.prototype.foo = function () {
    console.log(this.data);
}
function inherit(Foo) {
    // TODO
}

var child = new (inherit(Parent))(123);
child.foo(); // 123;
```
:::
::: tab label=解
* 注意this传给父函数
* 注意原型链拼接时的constructor保持
```js
function inherit(Foo) {
    const Child = function (...args) {
        Foo.call(this, ...args);
    }
    Child.prototype = Object.create(Foo.prototype);
    Child.prototype.constructor = Child;
    return Child;
}
```
:::
::::
## 68.localStorate
:::: tabs
::: tab label=题
* 设置一个原型方法，让localstorage有set和get方法，比setItem、getItem更好用，能够判断是否有时效性
```js
localStorage.set('name', 'hdy', 1000 * 10);
localStorage.set('age', 18, 1000 * 20);

setTimout(() => console.log(localStorage.get(name)), 9000); // hdy
setTimout(() => console.log(localStorage.get(name)), 11000); // null
```
:::
::: tab label=解
```html
<body>
    <script>
        localStorage.__proto__.get = key => {
            const item = localStorage.getItem(key);
            let val;
            try {
                val = JSON.parse(item);
            } catch (e) {
                val = null;
            }
            if (val === null || val.end < Date.now()) {
                localStorage.removeItem(key);
                return null;
            }
            return val.data;
        }
        localStorage.__proto__.set = (key, data, time = 1000 * 5) => {
            const val = {
                end: Date.now() + time,
                data
            }
            localStorage.setItem(key, JSON.stringify(val));
        }

        localStorage.set('name', 'hdy', 1000 * 10);
        localStorage.set('age', 18, 1000 * 20);

        setTimeout(() => console.log(localStorage.get("name")), 9000); // hdy
        setTimeout(() => console.log(localStorage.get("name")), 11000); // null

    </script>
</body>

```
:::
::::
## 69.手写JSONP实现
:::: tabs
::: tab label=解
```html
<body>
    <script>
        function callback(data) {
            console.log(data);
        }
        (function () {
            const script = document.createElement('script');
            script.src = 'http://localhost:8090';
            document.body.appendChild(script);
        })();

    </script>
</body>
```
:::
::: tab label=服务器端
```js
const express = require('express');
const app = new express();
app.listen(8090);

const data = {
    name: 'hdy',
    age: 18
}

app.get('/', (req, res) => {
    res.send(`callback(${JSON.stringify(data)})`);
});
```
:::
::::
## 70.无符号计算
:::: tabs
::: tab label=题
* [力扣](https://leetcode-cn.com/problems/qiu-12n-lcof/)
* 计算`1 + 2 + 3...+ n`，不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
:::
::: tab label=解
* 推到已知公式为`(n + 1) * n / 2`
* repeat可以做乘法
* 右移运算符 >> 可以做除法，相当于除以Math.pow(2, x);
```js
var sumNums = function(n) {
    return ' '.repeat(n + 1).repeat(n).length >> 1;
};
```
* 证明
```js
function test(n, y) {
    return Math.floor(n / Math.pow(2, y)) === n >> y;
}

console.log(test(16, 2));
```
:::
::::
## 71.简易JSX compiler
:::: tabs
::: tab label=题
```js
const str = `<MyButton color="blue" shadowSize={2}>Click Me</MyButton>`;

console.log(compiler(str));
// {
//   tagName: 'MyButton',
//   props: { color: 'blue', shadowSize: '2' },
//   content: 'Click Me'
// }
```
:::
::: tab label=解
```js
function compiler(jsx) {
    const tagReg = /(?<=\s*\<)([A-Z]\w*)([^\>]*)\>(.*)<\/\1>/s;
    const getProps = row => {
        const props = {};
        row = row.trim();
        if (row === '') return props;
        row.split(/\s+/).forEach(item => {
            const [key, val] = item.split(/\s*=\s*/);
            props[key] = val.match(/^['"{](.*)['"}]/)[1];
        })
        return props;
    }
    if (tagReg.test(jsx)) {
        const [_, tagName, rowProps, content] = (tagReg.exec(jsx));
        const props = getProps(rowProps);
        return { tagName, props, content }
    } else {
        return '';
    }
}
```
:::
::::