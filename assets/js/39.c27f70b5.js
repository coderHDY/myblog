(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{662:function(v,_,l){v.exports=l.p+"assets/img/jinchengzhuangtai.28238eda.png"},868:function(v,_,l){"use strict";l.r(_);var o=l(7),t=Object(o.a)({},(function(){var v=this,_=v.$createElement,o=v._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[o("h2",{attrs:{id:"操作系统介绍"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#操作系统介绍"}},[v._v("#")]),v._v(" 操作系统介绍")]),v._v(" "),o("tabs",{attrs:{type:"border-card"}},[o("tab",{attrs:{label:"作用"}},[o("ol",[o("li",[v._v("操作系统作为"),o("code",[v._v("系统资源的管理者")]),v._v("，需要提供什么样的功能？\n"),o("ul",[o("li",[v._v("提供的功能："),o("code",[v._v("文件管理")]),v._v("、"),o("code",[v._v("设备管理")]),v._v("、"),o("code",[v._v("处理机(cpu)管理")]),v._v("、"),o("code",[v._v("存储器(运行内存)管理")])])])]),v._v(" "),o("li",[v._v("操作系统作为"),o("code",[v._v("用户与计算机硬件之间的接口")]),v._v("需要提供什么功能？\n"),o("ul",[o("li",[v._v("命令接口："),o("code",[v._v("联机命令接口（命令行）")]),v._v("、"),o("code",[v._v("脱机命令接口（批处理命令接口）（sh/bat文件执行）")])]),v._v(" "),o("li",[v._v("程序接口：允许用户通过程序间接使用(.dll)")]),v._v(" "),o("li",[v._v("GUI：图形用户接口(图像拖拽等操作图形操作界面)")])])]),v._v(" "),o("li",[v._v("操作系统作为最接近系统硬件的层次，需要在纯硬件基础上实现什么功能？\n"),o("ul",[o("li",[v._v("调度系统资源，提供给用户更方便的使用")])])])]),v._v(" "),o("blockquote",[o("p",[o("code",[v._v("进程")]),v._v("是程序执行的过程，执行前需要将该程序放到cpu当中，才会被cpu处理")])])]),v._v(" "),o("tab",{attrs:{label:"特征"}},[o("ul",[o("li",[o("code",[v._v("并发")]),v._v("：两个或多个事件在"),o("code",[v._v("宏观上同时发生")]),v._v("，"),o("code",[v._v("微观上交替发生")]),v._v("。（"),o("code",[v._v("并行")]),v._v("是宏观和微观都同时发生）")]),v._v(" "),o("li",[v._v("共享：指系统资源供多个并发资源同时使用，分为"),o("code",[v._v("互斥共享")]),v._v("(摄像头的使用)、"),o("code",[v._v("同时共享")]),v._v("(同时读取文件)")]),v._v(" "),o("li",[v._v("虚拟："),o("code",[v._v("空分复用技术")]),v._v("(虚拟存储器，4G运存运行程序远超4G)、"),o("code",[v._v("时分复用技术")]),v._v("(虚拟处理器，单核处理多任务)")]),v._v(" "),o("li",[v._v("异步：进程并不总是一次性执行完的，而是走走停停，"),o("strong",[v._v("根据操作系统的调度，微观上异步的处理完所有的指令")])])])]),v._v(" "),o("tab",{attrs:{label:"分类"}},[o("blockquote",[o("p",[v._v("发展顺序")])]),v._v(" "),o("ul",[o("li",[v._v("手工操作系统:人机交互慢，浪费资源")]),v._v(" "),o("li",[v._v("批处理阶段：单道批处理系统、"),o("strong",[v._v("多道批处理系统(操作系统开始出现，调度程序并发执行)")])]),v._v(" "),o("li",[v._v("分时操作系统："),o("strong",[v._v("轮询机制处理交互任务")]),v._v("，人感觉不出来的时间差。(缺点：不能处理紧急任务)")]),v._v(" "),o("li",[v._v("实时操作系统：\n"),o("ul",[o("li",[v._v("硬实时系统：规定时间内必须执行完（航空导弹、自动驾驶系统）")]),v._v(" "),o("li",[v._v("软实时系统：能接受偶尔实时性不强（订票系统）")])])]),v._v(" "),o("li",[v._v("网络操作系统")]),v._v(" "),o("li",[v._v("分布式操作系统")]),v._v(" "),o("li",[v._v("个人计算机操作系统")])])]),v._v(" "),o("tab",{attrs:{label:"运行机制"}},[o("ul",[o("li",[v._v("两种运行状态："),o("code",[v._v("用户态")]),v._v("、"),o("code",[v._v("核心态")])]),v._v(" "),o("li",[v._v("CPU区分运行态的方式："),o("code",[v._v("PSW标志位关键字")]),v._v("，0/1")]),v._v(" "),o("li",[v._v("两种程序：核心程序(运行在核心态，能够执行"),o("code",[v._v("特权指令")]),v._v(")、应用程序(运行在用户态，只能执行"),o("code",[v._v("非特权指令")]),v._v(")")]),v._v(" "),o("li",[o("code",[v._v("中断")]),v._v("使cpu进入"),o("code",[v._v("核心态")]),v._v("。发生了中断，就意味着操作系统的介入，cpu的核心态可以让操作系统要用特权指令切换系统的控制权，中断控制是并发执行的核心")]),v._v(" "),o("li",[o("strong",[v._v("用户态和核心态的切换")]),v._v("：\n"),o("ul",[o("li",[v._v("用户态 -> 核心态：中断(唯一途径)")]),v._v(" "),o("li",[v._v("核心态 -> 用户态：执行一条特权指令，将程序的状态字"),o("code",[v._v("PSW")]),v._v("改为用户态")])])])])]),v._v(" "),o("tab",{attrs:{label:"系统调用"}},[o("ul",[o("li",[o("code",[v._v("系统调用")]),v._v("过程：\n"),o("ol",[o("li",[v._v("传递系统调用参数")]),v._v(" "),o("li",[v._v("执行陷入指令（中断指令的一种），产生内中断，系统进入核心态")]),v._v(" "),o("li",[v._v("执行系统调用相应的应用程序")]),v._v(" "),o("li",[v._v("返回用户程序")])])])])])],1),v._v(" "),o("h2",{attrs:{id:"进程"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[v._v("#")]),v._v(" 进程")]),v._v(" "),o("tabs",{attrs:{type:"border-card"}},[o("tab",{attrs:{label:"概念"}},[o("ul",[o("li",[v._v("程序段、数据段、PCB共同组成了"),o("code",[v._v("进程实体")]),v._v("(进程印象)")]),v._v(" "),o("li",[v._v("创建进程，实际上就是创建进程的PCB，"),o("code",[v._v("PCB是进程存在的唯一标识")])]),v._v(" "),o("li",[o("strong",[v._v("进程是进程实体的运行过程，是系统资源分配和调度的独立单位")])])])]),v._v(" "),o("tab",{attrs:{label:"PCB"}},[o("blockquote",[o("p",[v._v("PCB包括的信息")])]),v._v(" "),o("ul",[o("li",[o("strong",[v._v("进程描述信息")]),v._v("：进程标识符PID，用户标识符UID")]),v._v(" "),o("li",[o("strong",[v._v("进程控制和管理信息")]),v._v("：进程当前状态，进程优先级")]),v._v(" "),o("li",[o("strong",[v._v("资源分配清单")]),v._v("：程序段指针，数据段指针，键盘，鼠标")]),v._v(" "),o("li",[o("strong",[v._v("处理机相关信息")]),v._v("：各种寄存器处理的值进行临时保存")])])]),v._v(" "),o("tab",{attrs:{label:"进程组织方式"}},[o("ul",[o("li",[o("code",[v._v("链接方式")]),v._v("：按照"),o("strong",[v._v("进程状态")]),v._v("将PCB分为多个"),o("strong",[v._v("队列")]),v._v("，操作系统持有指向各队列的"),o("strong",[v._v("指针")]),v._v("。")]),v._v(" "),o("li",[o("code",[v._v("索引方式")]),v._v("：根据进程状态不同，建立几张索引表，操作系统持有各索引表的指针。")])]),v._v(" "),o("blockquote",[o("p",[v._v("链接指针分为："),o("code",[v._v("执行指针")]),v._v("、"),o("code",[v._v("就绪队列指针")]),v._v("、"),o("code",[v._v("阻塞队列指针")]),o("br"),v._v("\n索引指针分为："),o("code",[v._v("执行指针")]),v._v("、"),o("code",[v._v("就绪索引表指针")]),v._v("、"),o("code",[v._v("阻塞索引表指针")])])])]),v._v(" "),o("tab",{attrs:{label:"特征"}},[o("ul",[o("li",[o("code",[v._v("动态性")]),v._v("：进程是程序一次执行的过程，是动态产生的、变化和消亡的。")]),v._v(" "),o("li",[o("code",[v._v("并发性")]),v._v("：内存中有多个进程实体，各进程可并发执行。")]),v._v(" "),o("li",[o("code",[v._v("独立性")]),v._v("："),o("strong",[v._v("进程是能独立运行、独立获得资源、独立接受调度的基本单位。")])]),v._v(" "),o("li",[o("code",[v._v("异步性")]),v._v("：各进城推进的速度不可预知，操作系统提供"),o("code",[v._v("进程同步机制")]),v._v("来解决异步问题")]),v._v(" "),o("li",[o("code",[v._v("结构性")]),v._v("："),o("strong",[v._v("每个进程都会配置PCB")]),v._v("。结构上看，进城由程序段、数据段、PCB组成。")])])]),v._v(" "),o("tab",{attrs:{label:"状态与转换"}},[o("ul",[o("li",[v._v("基本状态："),o("code",[v._v("就绪态")]),v._v("、"),o("code",[v._v("阻塞态")]),v._v("、"),o("code",[v._v("运行态")]),v._v("（"),o("strong",[v._v("硬件有几核就最多有几个同时处于运行态的进程")]),v._v("）")]),v._v(" "),o("li",[v._v("其他状态：\n"),o("ul",[o("li",[o("code",[v._v("创建态")]),v._v("（将程序的数据段和程序段放入对应的内存中，创建程序的PCB）")]),v._v(" "),o("li",[o("code",[v._v("终止态")]),v._v("（进程所占内存和设备正在回收，撤销PCB）\n"),o("img",{attrs:{src:l(662),alt:""}})])])])])]),v._v(" "),o("tab",{attrs:{label:"进程控制"}},[o("blockquote",[o("p",[v._v("进程控制过程PCB控制信息不能存储错乱，因此这个"),o("strong",[v._v("过程不能被中断")])])]),v._v(" "),o("ul",[o("li",[v._v("进程的控制是通过"),o("code",[v._v("原语")]),v._v("实现的，原语的特点是"),o("strong",[v._v("不可中断")]),v._v(",原语需要运行在"),o("strong",[v._v("核心态")]),v._v("，主要工作：\n"),o("ul",[o("li",[v._v("更新PCB信息：修改当前PCB运行状态，准备下一个PCB需要的运行环境")]),v._v(" "),o("li",[v._v("将PCB插入到合适的队列")]),v._v(" "),o("li",[v._v("分配/回收资源")])])])])]),v._v(" "),o("tab",{attrs:{label:"进程通信"}},[o("blockquote",[o("p",[v._v("前提原因：每个进程拥有"),o("strong",[v._v("操作系统分配的内存地址空间，相互独立，其他进程无法直接访问。")])])]),v._v(" "),o("ul",[o("li",[o("code",[v._v("共享存储")]),v._v("：操作系统为两个进程提供一个"),o("code",[v._v("共享空间")]),v._v("，但两个进程访问此空间权限是"),o("strong",[v._v("互斥的")]),v._v(" "),o("ul",[o("li",[v._v("基于数据结构共享：（例）操作系统规定共享区只能放"),o("strong",[v._v("固定")]),v._v("长度为100的数组，分次轮流读写（低级共享）")]),v._v(" "),o("li",[v._v("基于存储区共享：给你们一块存储区自己玩（高级共享）")])])]),v._v(" "),o("li",[o("code",[v._v("管道通信")]),v._v("：\n"),o("ul",[o("li",[v._v("操作系统在内存中开辟一个缓冲区(pip)，"),o("strong",[v._v("写满再读，读空再写")])]),v._v(" "),o("li",[v._v("管道只能是"),o("code",[v._v("半双工通信")]),v._v("，要实现双向同时通信，则需要两个管道。")])])]),v._v(" "),o("li",[o("code",[v._v("消息传递")]),v._v("：(用"),o("code",[v._v("原语")]),v._v("发送)"),o("code",[v._v("消息头")]),v._v("("),o("strong",[v._v("发射进程id，接收进程id，消息类型，消息长度")]),v._v(")、"),o("code",[v._v("消息体")]),v._v(" "),o("ul",[o("li",[v._v("直接通信方式：每个进程有一个消息缓冲队列，直接通信就是把消息挂在对应进程的这个队列上")]),v._v(" "),o("li",[v._v("间接通信方式：系统会为各个进程提供一个信箱(类似邮箱)作为中间载体，大家根据"),o("code",[v._v("进程id")]),v._v("确定收发件人")])])])]),v._v(" "),o("blockquote",[o("p",[o("code",[v._v("半双工通信")]),v._v("：数据可以正向传输，也可以反向传输，但一个时间段内只能有一个方向传输")])])])],1)],1)}),[],!1,null,null,null);_.default=t.exports}}]);